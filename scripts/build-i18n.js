#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const localesDir = path.join(__dirname, '..', 'shared-i18n');
const outDir = path.join(__dirname, '..', 'public', 'js', 'min');
if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

const localeFiles = fs.readdirSync(localesDir).filter(f => f.endsWith('.json'));
if (localeFiles.length === 0) {
  console.error('No locale files found in shared-i18n');
  process.exit(1);
}

const locales = {};
let referenceKeys = null;
let hasErrors = false;

for (const file of localeFiles) {
  const full = path.join(localesDir, file);
  const raw = fs.readFileSync(full, 'utf8');
  let json;
  try {
    json = JSON.parse(raw);
  } catch (e) {
    console.error(`Invalid JSON in ${file}:`, e.message);
    hasErrors = true;
    continue;
  }
  const lang = path.basename(file, '.json');
  locales[lang] = json;
  const keys = Object.keys(json).sort();
  if (!referenceKeys) referenceKeys = keys;
  const missing = referenceKeys.filter(k => !keys.includes(k));
  const extra = keys.filter(k => !referenceKeys.includes(k));
  if (missing.length) {
    console.error(`Locale ${lang} is missing keys:`, missing.join(', '));
    hasErrors = true;
  }
  if (extra.length) {
    console.error(`Locale ${lang} has extra keys:`, extra.join(', '));
    hasErrors = true;
  }
}

if (hasErrors) {
  console.error('i18n validation failed. Fix the issues above.');
  process.exit(1);
}

const hash = crypto.createHash('sha256').update(JSON.stringify(locales)).digest('hex').slice(0, 8);

const serializedLocales = JSON.stringify(locales, null, 2)
  .replace(/`/g, '\\`')
  .replace(/<\/script>/gi, '<\\/script>');

const runtime = `/*! Generated by build-i18n.js */
(function(){
  const locales = ${serializedLocales};
  const DEFAULT_LANG = 'en';
  function getInitialLang(){
    const stored = localStorage.getItem('getty-language');
    if (stored && locales[stored]) return stored;
    return DEFAULT_LANG;
  }
  let currentLang = getInitialLang();
  function t(key){
    return (locales[currentLang] && locales[currentLang][key]) || locales[DEFAULT_LANG][key] || key;
  }
  function apply(){
    document.documentElement.lang = currentLang;
    document.querySelectorAll('[data-i18n]').forEach(el=>{
      const key = el.getAttribute('data-i18n');
      const value = t(key);
      if (/<\\//.test(value)) {
        el.innerHTML = value;
      } else {
        el.textContent = value;
      }
    });
    const title = document.querySelector('title');
    if (title) {
      const isAdmin = window.location.pathname.startsWith('/admin');
      title.textContent = t(isAdmin ? 'adminTitle' : 'title');
    }
    const metaDesc = document.querySelector('meta[name="description"]');
    if (metaDesc) metaDesc.setAttribute('content', t('description'));
  }
  async function setLanguage(lang){
    if (!locales[lang]) return;
    currentLang = lang;
    localStorage.setItem('getty-language', lang);
    const isAdmin = window.location.pathname.startsWith('/admin');
    if (isAdmin) {
      try {
        const hdrName = (window.__GETTY_CSRF_HEADER || 'x-csrf-token');
        let token = window.__GETTY_CSRF_TOKEN || '';
        async function fetchToken(){
          try {
            const r = await fetch('/api/admin/csrf', { credentials: 'include' });
            if (!r.ok) return null;
            const j = await r.json();
            return j && j.csrfToken ? j.csrfToken : null;
          } catch { return null; }
        }
        if (!token) { token = await fetchToken(); if (token) window.__GETTY_CSRF_TOKEN = token; }
        async function postLang(tok){
          const headers = { 'Content-Type':'application/json' };
          if (tok) headers[hdrName] = tok;
          return fetch('/api/language', { method:'POST', headers, body: JSON.stringify({ language: lang }) });
        }
        let resp = await postLang(token);
        if (!resp.ok && (resp.status === 401 || resp.status === 403)) {
          token = await fetchToken();
          if (token) window.__GETTY_CSRF_TOKEN = token;
          try { await postLang(token); } catch {}
        }
      } catch {}
    }
    apply();
  }
  function initSelectors(){
    document.querySelectorAll('.language-selector').forEach(sel=>{
      sel.value = currentLang;
      sel.addEventListener('change', e=>{ setLanguage(e.target.value); });
    });
  }
  document.addEventListener('DOMContentLoaded', ()=>{
    apply();
    initSelectors();
  });
  window.__i18n = { setLanguage, t, get current(){ return currentLang; }, locales: Object.keys(locales), version:'${hash}' };
})();
`;

const outFile = path.join(outDir, 'i18n-runtime.js');
fs.writeFileSync(outFile, runtime, 'utf8');
console.log(`i18n runtime generated: js/min/i18n-runtime.js (version ${hash})`);

try {
  let minified = runtime
    .replace(/^\s+/gm, '')
    .replace(/\n{2,}/g, '\n')
    .replace(/\/\*![\s\S]*?\*\//g, '')
    .replace(/\/\*(?!!)[\s\S]*?\*\//g, '')
    .replace(/(^|\n)\s*\/\/.*(?=\n)/g, '')
    .trim();

  if (!/^\/\*!/.test(minified)) {
    minified = '/*! Generated by build-i18n.js */' + minified;
  }
  const minFile = path.join(outDir, 'i18n-runtime.min.js');
  fs.writeFileSync(minFile, minified, 'utf8');
  console.log('i18n runtime minified: js/min/i18n-runtime.min.js');
} catch (e) {
  console.warn('Failed to produce minified i18n runtime:', e.message);
}

try {
  const projectRoot = path.join(__dirname, '..');
  const htmlTargets = [];

  const srcIndex = path.join(projectRoot, 'src', 'index.html');
  if (fs.existsSync(srcIndex)) htmlTargets.push(srcIndex);

  const widgetsDir = path.join(projectRoot, 'public', 'widgets');
  if (fs.existsSync(widgetsDir)) {
    for (const f of fs.readdirSync(widgetsDir)) {
      if (f.endsWith('.html')) htmlTargets.push(path.join(widgetsDir, f));
    }
  }

  const welcomeHtml = path.join(projectRoot, 'public', 'welcome.html');
  if (fs.existsSync(welcomeHtml)) htmlTargets.push(welcomeHtml);

  const pattern = /\/js\/min\/i18n-runtime\.js(?:\?v=[a-z0-9]+)?/g;
  let updatedCount = 0;
  htmlTargets.forEach(file => {
    let content = fs.readFileSync(file, 'utf8');
    if (pattern.test(content)) {
      content = content.replace(pattern, `/js/min/i18n-runtime.js?v=${hash}`);
      fs.writeFileSync(file, content, 'utf8');
      updatedCount++;
      console.log(`Updated i18n runtime version in ${path.relative(projectRoot, file)}`);
    }
  });
  if (!updatedCount) {
    console.warn('Warning: No HTML references to /js/min/i18n-runtime.js were updated.');
  }
} catch (e) {
  console.warn('Failed to auto-update HTML i18n runtime references:', e.message);
}
