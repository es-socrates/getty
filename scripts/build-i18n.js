#!/usr/bin/env node
/**
 * Build script for shared i18n.
 * - Validates that all locale JSON files share identical key sets.
 * - Generates a runtime bundle for non-Vue pages/widgets: public/js/min/i18n-runtime.js
 * - Adds a version hash for cache busting.
 */
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const localesDir = path.join(__dirname, '..', 'shared-i18n');
const outDir = path.join(__dirname, '..', 'public', 'js', 'min');

if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

const localeFiles = fs.readdirSync(localesDir).filter(f => f.endsWith('.json'));
if (localeFiles.length === 0) {
  console.error('No locale files found in shared-i18n');
  process.exit(1);
}

const locales = {};
let referenceKeys = null;
let hasErrors = false;

for (const file of localeFiles) {
  const full = path.join(localesDir, file);
  const raw = fs.readFileSync(full, 'utf8');
  let json;
  try {
    json = JSON.parse(raw);
  } catch (e) {
    console.error(`Invalid JSON in ${file}:`, e.message);
    hasErrors = true;
    continue;
  }
  const lang = path.basename(file, '.json');
  locales[lang] = json;
  const keys = Object.keys(json).sort();
  if (!referenceKeys) referenceKeys = keys;
  const missing = referenceKeys.filter(k => !keys.includes(k));
  const extra = keys.filter(k => !referenceKeys.includes(k));
  if (missing.length) {
    console.error(`Locale ${lang} is missing keys:`, missing.join(', '));
    hasErrors = true;
  }
  if (extra.length) {
    console.error(`Locale ${lang} has extra keys:`, extra.join(', '));
    hasErrors = true;
  }
}

if (hasErrors) {
  console.error('i18n validation failed. Fix the issues above.');
  process.exit(1);
}

// Hash for versioning
const hash = crypto.createHash('sha256').update(JSON.stringify(locales)).digest('hex').slice(0, 8);

const runtime = `/*! Generated by build-i18n.js */\n(function(){\n  const locales = ${JSON.stringify(locales)};\n  const DEFAULT_LANG = 'en';\n  function getInitialLang(){\n    const stored = localStorage.getItem('getty-language');\n    if (stored && locales[stored]) return stored;\n    return DEFAULT_LANG;\n  }\n  let currentLang = getInitialLang();\n  function t(key){\n    return (locales[currentLang] && locales[currentLang][key]) || locales[DEFAULT_LANG][key] || key;\n  }\n  function apply(){\n    document.documentElement.lang = currentLang;\n    document.querySelectorAll('[data-i18n]').forEach(el=>{\n      const key = el.getAttribute('data-i18n');\n      const value = t(key);\n      if (/</.test(value)) {\n        el.innerHTML = value;\n      } else {\n        el.textContent = value;\n      }\n    });\n    const title = document.querySelector('title');\n    if (title) {\n      const isAdmin = window.location.pathname.startsWith('/admin');\n      title.textContent = t(isAdmin ? 'adminTitle' : 'title');\n    }\n    const metaDesc = document.querySelector('meta[name="description"]');\n    if (metaDesc) metaDesc.setAttribute('content', t('description'));\n  }\n  function setLanguage(lang){\n    if (!locales[lang]) return;\n    currentLang = lang;\n    localStorage.setItem('getty-language', lang);\n    try {\n      fetch('/api/language', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ language: lang })});\n    } catch(_){}\n    apply();\n  }\n  function initSelectors(){\n    document.querySelectorAll('.language-selector').forEach(sel=>{\n      sel.value = currentLang;\n      sel.addEventListener('change', e=>{ setLanguage(e.target.value); });\n    });\n  }\n  document.addEventListener('DOMContentLoaded', ()=>{\n    apply();\n    initSelectors();\n  });\n  window.__i18n = { setLanguage, t, get current(){ return currentLang; }, locales: Object.keys(locales), version:'${hash}' };\n})();\n`;

const outFile = path.join(outDir, 'i18n-runtime.js');
fs.writeFileSync(outFile, runtime, 'utf8');
console.log(`i18n runtime generated: js/min/i18n-runtime.js (version ${hash})`);

// Auto-update version query parameter in HTML files referencing the runtime
// Strategy:
//  - Update source HTML (src/index.html) before minification step so minify-html picks up the new hash.
//  - Update widget HTMLs under public/widgets (served as-is) so they always point to latest hash.
//  - Any existing ?v=... is replaced. If absent, it's appended.
try {
  const projectRoot = path.join(__dirname, '..');
  const htmlTargets = [];

  // src HTML (will be minified later in build pipeline)
  const srcIndex = path.join(projectRoot, 'src', 'index.html');
  if (fs.existsSync(srcIndex)) htmlTargets.push(srcIndex);

  // Widget HTMLs (public/widgets/*.html)
  const widgetsDir = path.join(projectRoot, 'public', 'widgets');
  if (fs.existsSync(widgetsDir)) {
    for (const f of fs.readdirSync(widgetsDir)) {
      if (f.endsWith('.html')) htmlTargets.push(path.join(widgetsDir, f));
    }
  }

  const pattern = /\/js\/min\/i18n-runtime\.js(?:\?v=[a-z0-9]+)?/g;
  let updatedCount = 0;
  htmlTargets.forEach(file => {
    let content = fs.readFileSync(file, 'utf8');
    if (pattern.test(content)) {
      content = content.replace(pattern, `/js/min/i18n-runtime.js?v=${hash}`);
      fs.writeFileSync(file, content, 'utf8');
      updatedCount++;
      console.log(`Updated i18n runtime version in ${path.relative(projectRoot, file)}`);
    }
  });
  if (!updatedCount) {
    console.warn('Warning: No HTML references to /js/min/i18n-runtime.js were updated.');
  }
} catch (e) {
  console.warn('Failed to auto-update HTML i18n runtime references:', e.message);
}
